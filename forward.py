# -*- coding: utf-8 -*-
"""Untitled15.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RAScL9JZOCHwtsGqjxzmMqQ4NCm-YLX2
"""

# 修改后的导入
import cupy as cp
import cupyx.scipy.sparse as cpsparse
from cupyx.scipy.sparse.linalg import spsolve
import matplotlib.pyplot as plt

# 物理常数
c0 = 299792458  # 真空中的光速，单位：m/s

# 定义介质和空气的折射率
n_medium = 1.5  # 介质的折射率（例如玻璃）
n_air = 1.0     # 空气的折射率

# 计算介质中的光速
c = c0 / n_medium  # 介质中的光速

# 空间参数
L = 0.1  # 立方体边长，单位：米
Nx = 21  # x方向的网格数
Ny = 21  # y方向的网格数
Nz = 21  # z方向的网格数
dx = L / (Nx - 1)
dy = L / (Ny - 1)
dz = L / (Nz - 1)

# 时间参数
T = 1e-7  # 总时间，单位：秒
dt = 1e-11  # 时间步长，单位：秒
Nt = int(T / dt)

# 计算折射率失配引起的反射率 R
R = ((n_air - n_medium) / (n_air + n_medium)) ** 2

# 计算边界条件中的系数 alpha
alpha = 2 * R / ((1 - R) * c * dt)

x = cp.linspace(0, L, Nx)
y = cp.linspace(0, L, Ny)
z = cp.linspace(0, L, Nz)
X, Y, Z = cp.meshgrid(x, y, z, indexing='ij')

# 扩散系数 D，单位：m^2/s
D = 1e-4

# 吸收系数 mu_a，单位：1/m，随空间变化
mu_a = cp.zeros((Nx, Ny, Nz))

# 定义吸收系数的空间分布
center = L / 2
radius = L / 4
# 修改为：
distance = cp.sqrt((X - center)**2 + (Y - center)**2 + (Z - center)**2)
mu_a = cp.where(distance <= radius, 100, 10)
mu_a = mu_a.flatten()

# 将 mu_a 展平成一维数组
mu_a = mu_a.flatten()

# 初始光子密度
phi = cp.zeros(Nx * Ny * Nz)

# 光源位置索引（在 z=0 面的中心）
source_x = 0
source_y = Ny // 4
source_z = Ny // 4
source_index = source_x * Ny * Nz + source_y * Nz + source_z

# 光源项 S（单位：1/(m^3·s)）
S = cp.zeros(Nx * Ny * Nz)
S[source_index] = 1e3  # 光源强度，可根据需要调整

import cupyx.scipy.sparse as cpsparse
# 总的节点数
N = Nx * Ny * Nz

# 创建稀疏矩阵（LIL 格式）
# 初始化空的列表用于存储稀疏矩阵的数据
A_data = []
A_row = []
A_col = []

# 系数
rx = c * D * dt / dx**2
ry = c * D * dt / dy**2
rz = c * D * dt / dz**2

# 预计算吸收项
c_mu_a_dt = c * dt * mu_a

# 已经定义并初始化了 A_data, A_row, A_col 列表

# 组装矩阵 A
for i in range(Nx):
    for j in range(Ny):
        for k in range(Nz):
            index = i * Ny * Nz + j * Nz + k

            # 初始化对角线元素
            A_diag = float(1 + c_mu_a_dt[index])

            # x方向邻居
            if i > 0:
                left = (i - 1) * Ny * Nz + j * Nz + k
                A_row.append(index)
                A_col.append(left)
                A_data.append(float(-rx))
                A_diag += float(rx)
            else:
                A_diag += float(rx * (1 + alpha * dx))
            if i < Nx - 1:
                right = (i + 1) * Ny * Nz + j * Nz + k
                A_row.append(index)
                A_col.append(right)
                A_data.append(float(-rx))
                A_diag += float(rx)
            else:
                A_diag += float(rx * (1 + alpha * dx))

            # y方向邻居
            if j > 0:
                front = i * Ny * Nz + (j - 1) * Nz + k
                A_row.append(index)
                A_col.append(front)
                A_data.append(float(-ry))
                A_diag += float(ry)
            else:
                A_diag += float(ry * (1 + alpha * dy))
            if j < Ny - 1:
                back = i * Ny * Nz + (j + 1) * Nz + k
                A_row.append(index)
                A_col.append(back)
                A_data.append(float(-ry))
                A_diag += float(ry)
            else:
                A_diag += float(ry * (1 + alpha * dy))

            # z方向邻居
            if k > 0:
                down = i * Ny * Nz + j * Nz + (k - 1)
                A_row.append(index)
                A_col.append(down)
                A_data.append(float(-rz))
                A_diag += float(rz)
            else:
                A_diag += float(rz * (1 + alpha * dz))
            if k < Nz - 1:
                up = i * Ny * Nz + j * Nz + (k + 1)
                A_row.append(index)
                A_col.append(up)
                A_data.append(float(-rz))
                A_diag += float(rz)
            else:
                A_diag += float(rz * (1 + alpha * dz))

            # 设置对角线元素
            A_row.append(index)
            A_col.append(index)
            A_data.append(float(A_diag))

# 在循环结束后，转换为 CuPy 数组并创建稀疏矩阵
A_data = cp.array(A_data)
A_row = cp.array(A_row)
A_col = cp.array(A_col)

A = cpsparse.coo_matrix((A_data, (A_row, A_col)), shape=(N, N)).tocsr()

from tqdm import tqdm  # 可选：用于显示进度条
import numpy as np

# 初始化右端项 b
b = cp.zeros(N)
me = 99999999
n = 0
# 时间步迭代
while me > 1e-5:
    print(f'\r{me}', end='', flush=True)
    # 右端项：phi^n + c * dt * S^{n+1}
    b = phi + c * dt * S

    # 在边界处添加罗宾边界条件的影响
    # 因为我们没有指定边界处的已知值，所以右端项无需额外调整

    # 求解线性方程组 A * phi_new = b
    phi_new = spsolve(A, b)

    # 避免负值
    phi_new[phi_new < 0] = 0

    # 更新
    phi = phi_new.copy()

    # 模拟脉冲光源，只在第一个时间步存在
    if n == 0:
        S = cp.zeros(N)
    phi_cpu = cp.asnumpy(phi)
    me = phi_cpu.mean()
    np.save(f'phi_{n}.npy', phi_cpu)
    n+=1



# 将 phi 恢复为三维数组
phi_3d = cp.asnumpy(phi.reshape((Nx, Ny, Nz)))

# 提取六个面的光子密度分布
face_x0 = cp.asnumpy(phi_3d[0, :, :])
face_xL = cp.asnumpy(phi_3d[-1, :, :])
face_y0 = cp.asnumpy(phi_3d[:, 0, :])
face_yL = cp.asnumpy(phi_3d[:, -1, :])
face_z0 = cp.asnumpy(phi_3d[:, :, 0])
face_zL = cp.asnumpy(phi_3d[:, :, -1])



# 输出每个面的总光子密度
print('Total photon density on each face at final time:')
print(f'Face x=0: {cp.sum(face_x0)}')
print(f'Face x=L: {cp.sum(face_xL)}')
print(f'Face y=0: {cp.sum(face_y0)}')
print(f'Face y=L: {cp.sum(face_yL)}')
print(f'Face z=0: {cp.sum(face_z0)}')
print(f'Face z=L: {cp.sum(face_zL)}')

# 可视化 z=L 面的光子密度分布
plt.imshow(face_yL.T, extent=[0, L, 0, L], origin='lower')
plt.xlabel('x (m)')
plt.ylabel('y (m)')
plt.title('Photon Density on Face y=L at Final Time')
plt.colorbar(label='Photon Density')
plt.show()

import shutil
from google.colab import files
import zipfile
import os
# 复制整个文件夹到'/content/folder'目录中
shutil.copytree('/content/dataoutput3', '/content/folder_copy4')

# 创建一个新的zip文件
zipObj = zipfile.ZipFile('folder3.zip', 'w', zipfile.ZIP_DEFLATED)

# 将整个文件夹添加到zip文件中
for foldername, subfolders, filenames in os.walk('/content/folder_copy4'):
    for filename in filenames:
        filepath = os.path.join(foldername, filename)
        zipObj.write(filepath, os.path.relpath(filepath, '/content/folder_copy4'))

# 关闭zip文件
zipObj.close()

# 下载zip文件
files.download('folder3.zip')